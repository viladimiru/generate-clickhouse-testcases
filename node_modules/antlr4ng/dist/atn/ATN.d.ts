import { IntervalSet } from "../misc/IntervalSet.js";
import { ATNState } from "./ATNState.js";
import { DecisionState } from "./DecisionState.js";
import { RuleStartState } from "./RuleStartState.js";
import { RuleStopState } from "./RuleStopState.js";
import { LexerAction } from "./LexerAction.js";
import { TokensStartState } from "./TokensStartState.js";
import type { ParserRuleContext } from "../ParserRuleContext.js";
export declare class ATN {
    #private;
    static INVALID_ALT_NUMBER: number;
    /** Represents the type of recognizer an ATN applies to */
    static readonly LEXER = 0;
    static readonly PARSER = 1;
    /**
     * Used for runtime deserialization of ATNs from strings
     * The type of the ATN.
     */
    readonly grammarType: number;
    /** The maximum value for any symbol recognized by a transition in the ATN. */
    readonly maxTokenType: number;
    readonly states: Array<ATNState | null>;
    /**
     * Each subrule/rule is a decision point and we must track them so we
     * can go back later and build DFA predictors for them.  This includes
     * all the rules, subrules, optional blocks, ()+, ()* etc...
     */
    readonly decisionToState: DecisionState[];
    /** Maps from rule index to starting state number. */
    ruleToStartState: Array<RuleStartState | null>;
    /** Maps from rule index to stop state number. */
    ruleToStopState: Array<RuleStopState | null>;
    readonly modeNameToStartState: Map<string, TokensStartState>;
    /**
     * For lexer ATNs, this maps the rule index to the resulting token type.
     * For parser ATNs, this maps the rule index to the generated bypass token
     * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}
     * deserialization option was specified; otherwise, this is `null`
     */
    ruleToTokenType: number[];
    /**
     * For lexer ATNs, this is an array of {@link LexerAction} objects which may
     * be referenced by action transitions in the ATN
     */
    lexerActions: LexerAction[];
    readonly modeToStartState: Array<RuleStartState | null>;
    constructor(grammarType: number, maxTokenType: number);
    /**
     * Compute the set of valid tokens that can occur starting in state `s`.
     * If `ctx` is null, the set of tokens will not include what can follow
     * the rule surrounding `s`. In other words, the set will be
     * restricted to tokens reachable staying within `s`'s rule.
     */
    nextTokens(atnState: ATNState, ctx?: ParserRuleContext): IntervalSet;
    addState(state: ATNState | null): void;
    removeState(state: ATNState): void;
    defineDecisionState(s: DecisionState): number;
    getDecisionState(decision: number): DecisionState | null;
    getNumberOfDecisions(): number;
    /**
     * Computes the set of input symbols which could follow ATN state number
     * `stateNumber` in the specified full `context`. This method
     * considers the complete parser context, but does not evaluate semantic
     * predicates (i.e. all predicates encountered during the calculation are
     * assumed true). If a path in the ATN exists from the starting state to the
     * {@link RuleStopState} of the outermost context without matching any
     * symbols, {@link Token//EOF} is added to the returned set.
     *
     * If `context` is `null`, it is treated as
     * {@link ParserRuleContext//EMPTY}.
     *
     * @param stateNumber the ATN state number
     * @param context the full parse context
     *
     * @returns {IntervalSet} The set of potentially valid input symbols which could follow the
     * specified state in the specified context.
     *
     * @throws IllegalArgumentException if the ATN does not contain a state with
     * number `stateNumber`
     */
    getExpectedTokens(stateNumber: number, context: ParserRuleContext | null): IntervalSet;
}
