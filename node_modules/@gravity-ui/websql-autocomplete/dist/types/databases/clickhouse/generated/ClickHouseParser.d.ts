import * as antlr from "antlr4ng";
import { ClickHouseParserVisitor } from "./ClickHouseParserVisitor.js";
export declare class ClickHouseParser extends antlr.Parser {
    static readonly ADD = 1;
    static readonly AFTER = 2;
    static readonly ALIAS = 3;
    static readonly ALL = 4;
    static readonly ALTER = 5;
    static readonly AND = 6;
    static readonly ANTI = 7;
    static readonly ANY = 8;
    static readonly ARRAY = 9;
    static readonly AS = 10;
    static readonly ASCENDING = 11;
    static readonly ASOF = 12;
    static readonly AST = 13;
    static readonly ASYNC = 14;
    static readonly ATTACH = 15;
    static readonly BETWEEN = 16;
    static readonly BOTH = 17;
    static readonly BY = 18;
    static readonly CASE = 19;
    static readonly CAST = 20;
    static readonly CHECK = 21;
    static readonly CLEAR = 22;
    static readonly CLUSTER = 23;
    static readonly CODEC = 24;
    static readonly COLLATE = 25;
    static readonly COLUMN = 26;
    static readonly COMMENT = 27;
    static readonly CONSTRAINT = 28;
    static readonly CREATE = 29;
    static readonly CROSS = 30;
    static readonly CUBE = 31;
    static readonly CURRENT = 32;
    static readonly DATABASE = 33;
    static readonly DATABASES = 34;
    static readonly DATE = 35;
    static readonly DAY = 36;
    static readonly DEDUPLICATE = 37;
    static readonly DEFAULT = 38;
    static readonly DELAY = 39;
    static readonly DELETE = 40;
    static readonly DESC = 41;
    static readonly DESCENDING = 42;
    static readonly DESCRIBE = 43;
    static readonly DETACH = 44;
    static readonly DICTIONARIES = 45;
    static readonly DICTIONARY = 46;
    static readonly DISK = 47;
    static readonly DISTINCT = 48;
    static readonly DISTRIBUTED = 49;
    static readonly DROP = 50;
    static readonly ELSE = 51;
    static readonly END = 52;
    static readonly ENGINE = 53;
    static readonly ESTIMATE = 54;
    static readonly EVENTS = 55;
    static readonly EXISTS = 56;
    static readonly EXPLAIN = 57;
    static readonly EXPRESSION = 58;
    static readonly EXTRACT = 59;
    static readonly FETCHES = 60;
    static readonly FINAL = 61;
    static readonly FIRST = 62;
    static readonly FLUSH = 63;
    static readonly FOLLOWING = 64;
    static readonly FOR = 65;
    static readonly FORMAT = 66;
    static readonly FREEZE = 67;
    static readonly FROM = 68;
    static readonly FULL = 69;
    static readonly FUNCTION = 70;
    static readonly GLOBAL = 71;
    static readonly GRANULARITY = 72;
    static readonly GROUP = 73;
    static readonly HAVING = 74;
    static readonly HIERARCHICAL = 75;
    static readonly HOUR = 76;
    static readonly ID = 77;
    static readonly IF = 78;
    static readonly ILIKE = 79;
    static readonly IN = 80;
    static readonly INDEX = 81;
    static readonly INF = 82;
    static readonly INJECTIVE = 83;
    static readonly INNER = 84;
    static readonly INSERT = 85;
    static readonly INTERVAL = 86;
    static readonly INTO = 87;
    static readonly IS = 88;
    static readonly IS_OBJECT_ID = 89;
    static readonly JOIN = 90;
    static readonly KEY = 91;
    static readonly KILL = 92;
    static readonly LAST = 93;
    static readonly LAYOUT = 94;
    static readonly LEADING = 95;
    static readonly LEFT = 96;
    static readonly LIFETIME = 97;
    static readonly LIKE = 98;
    static readonly LIMIT = 99;
    static readonly LIVE = 100;
    static readonly LOCAL = 101;
    static readonly LOGS = 102;
    static readonly MATERIALIZE = 103;
    static readonly MATERIALIZED = 104;
    static readonly MAX = 105;
    static readonly MERGES = 106;
    static readonly MIN = 107;
    static readonly MINUTE = 108;
    static readonly MODIFY = 109;
    static readonly MONTH = 110;
    static readonly MOVE = 111;
    static readonly MUTATION = 112;
    static readonly NAN_SQL = 113;
    static readonly NO = 114;
    static readonly NOT = 115;
    static readonly NULL_SQL = 116;
    static readonly NULLS = 117;
    static readonly OFFSET = 118;
    static readonly ON = 119;
    static readonly OPTIMIZE = 120;
    static readonly OR = 121;
    static readonly ORDER = 122;
    static readonly OUTER = 123;
    static readonly OUTFILE = 124;
    static readonly OVER = 125;
    static readonly PARTITION = 126;
    static readonly PIPELINE = 127;
    static readonly PLAN = 128;
    static readonly POPULATE = 129;
    static readonly PRECEDING = 130;
    static readonly PREWHERE = 131;
    static readonly PRIMARY = 132;
    static readonly PROJECTION = 133;
    static readonly QUARTER = 134;
    static readonly QUERY = 135;
    static readonly RANGE = 136;
    static readonly RELOAD = 137;
    static readonly REMOVE = 138;
    static readonly RENAME = 139;
    static readonly REPLACE = 140;
    static readonly REPLICA = 141;
    static readonly REPLICATED = 142;
    static readonly RIGHT = 143;
    static readonly ROLLUP = 144;
    static readonly ROW = 145;
    static readonly ROWS = 146;
    static readonly SAMPLE = 147;
    static readonly SECOND = 148;
    static readonly SELECT = 149;
    static readonly SEMI = 150;
    static readonly SENDS = 151;
    static readonly SET = 152;
    static readonly SETTINGS = 153;
    static readonly SHOW = 154;
    static readonly SOURCE = 155;
    static readonly START = 156;
    static readonly STOP = 157;
    static readonly SUBSTRING = 158;
    static readonly SYNC = 159;
    static readonly SYNTAX = 160;
    static readonly SYSTEM = 161;
    static readonly TABLE = 162;
    static readonly TABLES = 163;
    static readonly TEMPORARY = 164;
    static readonly TEST = 165;
    static readonly THEN = 166;
    static readonly TIES = 167;
    static readonly TIMEOUT = 168;
    static readonly TIMESTAMP = 169;
    static readonly TO = 170;
    static readonly TOP = 171;
    static readonly TOTALS = 172;
    static readonly TRAILING = 173;
    static readonly TRIM = 174;
    static readonly TREE = 175;
    static readonly TRUNCATE = 176;
    static readonly TTL = 177;
    static readonly TYPE = 178;
    static readonly UNBOUNDED = 179;
    static readonly UNION = 180;
    static readonly UPDATE = 181;
    static readonly USE = 182;
    static readonly USING = 183;
    static readonly UUID = 184;
    static readonly VALUES = 185;
    static readonly VIEW = 186;
    static readonly VOLUME = 187;
    static readonly WATCH = 188;
    static readonly WEEK = 189;
    static readonly WHEN = 190;
    static readonly WHERE = 191;
    static readonly WINDOW = 192;
    static readonly WITH = 193;
    static readonly YEAR = 194;
    static readonly JSON_FALSE = 195;
    static readonly JSON_TRUE = 196;
    static readonly IDENTIFIER = 197;
    static readonly FLOATING_LITERAL = 198;
    static readonly OCTAL_LITERAL = 199;
    static readonly DECIMAL_LITERAL = 200;
    static readonly HEXADECIMAL_LITERAL = 201;
    static readonly STRING_LITERAL = 202;
    static readonly ARROW = 203;
    static readonly ASTERISK = 204;
    static readonly BACKQUOTE = 205;
    static readonly BACKSLASH = 206;
    static readonly COLON = 207;
    static readonly COMMA = 208;
    static readonly CONCAT = 209;
    static readonly DASH = 210;
    static readonly DOT = 211;
    static readonly EQ_DOUBLE = 212;
    static readonly EQ_SINGLE = 213;
    static readonly GE = 214;
    static readonly GT = 215;
    static readonly LBRACE = 216;
    static readonly LBRACKET = 217;
    static readonly LE = 218;
    static readonly LPAREN = 219;
    static readonly LT = 220;
    static readonly NOT_EQ = 221;
    static readonly PERCENT = 222;
    static readonly PLUS = 223;
    static readonly QUESTIONMARK = 224;
    static readonly QUOTE_DOUBLE = 225;
    static readonly QUOTE_SINGLE = 226;
    static readonly RBRACE = 227;
    static readonly RBRACKET = 228;
    static readonly RPAREN = 229;
    static readonly SEMICOLON = 230;
    static readonly SLASH = 231;
    static readonly UNDERSCORE = 232;
    static readonly MULTI_LINE_COMMENT = 233;
    static readonly SINGLE_LINE_COMMENT = 234;
    static readonly WHITESPACE = 235;
    static readonly RULE_root = 0;
    static readonly RULE_statements = 1;
    static readonly RULE_statement = 2;
    static readonly RULE_notInsertStatement = 3;
    static readonly RULE_commonTableExpressionStatement = 4;
    static readonly RULE_namedQuery = 5;
    static readonly RULE_columnAliases = 6;
    static readonly RULE_alterStatement = 7;
    static readonly RULE_alterTableClause = 8;
    static readonly RULE_assignmentExpressionList = 9;
    static readonly RULE_assignmentExpression = 10;
    static readonly RULE_tableColumnPropertyType = 11;
    static readonly RULE_partitionClause = 12;
    static readonly RULE_attachStatement = 13;
    static readonly RULE_checkStatement = 14;
    static readonly RULE_deleteStatement = 15;
    static readonly RULE_createTableStatement = 16;
    static readonly RULE_createDatabaseStatement = 17;
    static readonly RULE_createDictionaryStatement = 18;
    static readonly RULE_createLiveViewStatement = 19;
    static readonly RULE_createMaterializedViewStatement = 20;
    static readonly RULE_createViewStatement = 21;
    static readonly RULE_createStatement = 22;
    static readonly RULE_dictionarySchemaClause = 23;
    static readonly RULE_dictionaryAttributeDefinition = 24;
    static readonly RULE_dictionaryEngineClause = 25;
    static readonly RULE_dictionaryPrimaryKeyClause = 26;
    static readonly RULE_dictionaryArgumentExpression = 27;
    static readonly RULE_sourceClause = 28;
    static readonly RULE_lifetimeClause = 29;
    static readonly RULE_layoutClause = 30;
    static readonly RULE_rangeClause = 31;
    static readonly RULE_dictionarySettingsClause = 32;
    static readonly RULE_clusterClause = 33;
    static readonly RULE_uuidClause = 34;
    static readonly RULE_destinationClause = 35;
    static readonly RULE_subqueryClause = 36;
    static readonly RULE_tableSchemaClause = 37;
    static readonly RULE_engineClause = 38;
    static readonly RULE_partitionByClause = 39;
    static readonly RULE_primaryKeyClause = 40;
    static readonly RULE_sampleByClause = 41;
    static readonly RULE_ttlClause = 42;
    static readonly RULE_engineExpression = 43;
    static readonly RULE_tableElementExpression = 44;
    static readonly RULE_tableColumnDefinition = 45;
    static readonly RULE_tableColumnPropertyExpression = 46;
    static readonly RULE_tableIndexDefinition = 47;
    static readonly RULE_tableProjectionDefinition = 48;
    static readonly RULE_codecExpression = 49;
    static readonly RULE_codecArgExpression = 50;
    static readonly RULE_ttlExpression = 51;
    static readonly RULE_describeStatement = 52;
    static readonly RULE_dropStatement = 53;
    static readonly RULE_existsStatement = 54;
    static readonly RULE_explainStatement = 55;
    static readonly RULE_insertStatement = 56;
    static readonly RULE_columnsClause = 57;
    static readonly RULE_dataClause = 58;
    static readonly RULE_valuesStatement = 59;
    static readonly RULE_killStatement = 60;
    static readonly RULE_optimizeStatement = 61;
    static readonly RULE_renameStatement = 62;
    static readonly RULE_projectionSelectStatement = 63;
    static readonly RULE_selectUnionStatement = 64;
    static readonly RULE_selectStatementWithParentheses = 65;
    static readonly RULE_selectStatement = 66;
    static readonly RULE_withClause = 67;
    static readonly RULE_topClause = 68;
    static readonly RULE_fromClause = 69;
    static readonly RULE_arrayJoinClause = 70;
    static readonly RULE_windowClause = 71;
    static readonly RULE_prewhereClause = 72;
    static readonly RULE_whereClause = 73;
    static readonly RULE_groupByClause = 74;
    static readonly RULE_havingClause = 75;
    static readonly RULE_orderByClause = 76;
    static readonly RULE_projectionOrderByClause = 77;
    static readonly RULE_limitByClause = 78;
    static readonly RULE_limitClause = 79;
    static readonly RULE_settingsClause = 80;
    static readonly RULE_joinExpression = 81;
    static readonly RULE_joinOperator = 82;
    static readonly RULE_joinOperatorCross = 83;
    static readonly RULE_joinConstraintClause = 84;
    static readonly RULE_sampleClause = 85;
    static readonly RULE_limitExpression = 86;
    static readonly RULE_orderExpressionList = 87;
    static readonly RULE_orderExpression = 88;
    static readonly RULE_ratioExpression = 89;
    static readonly RULE_settingExpressionList = 90;
    static readonly RULE_settingExpression = 91;
    static readonly RULE_windowExpression = 92;
    static readonly RULE_windowPartitionByClause = 93;
    static readonly RULE_windowOrderByClause = 94;
    static readonly RULE_windowFrameClause = 95;
    static readonly RULE_windowFrameExtend = 96;
    static readonly RULE_windowFrameBound = 97;
    static readonly RULE_setStatement = 98;
    static readonly RULE_showStatement = 99;
    static readonly RULE_systemStatement = 100;
    static readonly RULE_truncateStatement = 101;
    static readonly RULE_useStatement = 102;
    static readonly RULE_watchStatement = 103;
    static readonly RULE_columnTypeExpression = 104;
    static readonly RULE_columnExpressionList = 105;
    static readonly RULE_columnsExpression = 106;
    static readonly RULE_columnExpression = 107;
    static readonly RULE_columnArgumentList = 108;
    static readonly RULE_columnArgumentExpression = 109;
    static readonly RULE_columnLambdaExpression = 110;
    static readonly RULE_columnIdentifier = 111;
    static readonly RULE_tableExpression = 112;
    static readonly RULE_tableFunctionExpression = 113;
    static readonly RULE_tableIdentifier = 114;
    static readonly RULE_tableArgList = 115;
    static readonly RULE_tableArgExpression = 116;
    static readonly RULE_databaseIdentifier = 117;
    static readonly RULE_floatingLiteral = 118;
    static readonly RULE_numberLiteral = 119;
    static readonly RULE_literal = 120;
    static readonly RULE_interval = 121;
    static readonly RULE_keyword = 122;
    static readonly RULE_keywordForAlias = 123;
    static readonly RULE_alias = 124;
    static readonly RULE_identifier = 125;
    static readonly RULE_identifierOrNull = 126;
    static readonly RULE_enumValue = 127;
    static readonly literalNames: (string | null)[];
    static readonly symbolicNames: (string | null)[];
    static readonly ruleNames: string[];
    get grammarFileName(): string;
    get literalNames(): (string | null)[];
    get symbolicNames(): (string | null)[];
    get ruleNames(): string[];
    get serializedATN(): number[];
    protected createFailedPredicateException(predicate?: string, message?: string): antlr.FailedPredicateException;
    constructor(input: antlr.TokenStream);
    root(): RootContext;
    statements(): StatementsContext;
    statement(): StatementContext;
    notInsertStatement(): NotInsertStatementContext;
    commonTableExpressionStatement(): CommonTableExpressionStatementContext;
    namedQuery(): NamedQueryContext;
    columnAliases(): ColumnAliasesContext;
    alterStatement(): AlterStatementContext;
    alterTableClause(): AlterTableClauseContext;
    assignmentExpressionList(): AssignmentExpressionListContext;
    assignmentExpression(): AssignmentExpressionContext;
    tableColumnPropertyType(): TableColumnPropertyTypeContext;
    partitionClause(): PartitionClauseContext;
    attachStatement(): AttachStatementContext;
    checkStatement(): CheckStatementContext;
    deleteStatement(): DeleteStatementContext;
    createTableStatement(): CreateTableStatementContext;
    createDatabaseStatement(): CreateDatabaseStatementContext;
    createDictionaryStatement(): CreateDictionaryStatementContext;
    createLiveViewStatement(): CreateLiveViewStatementContext;
    createMaterializedViewStatement(): CreateMaterializedViewStatementContext;
    createViewStatement(): CreateViewStatementContext;
    createStatement(): CreateStatementContext;
    dictionarySchemaClause(): DictionarySchemaClauseContext;
    dictionaryAttributeDefinition(): DictionaryAttributeDefinitionContext;
    dictionaryEngineClause(): DictionaryEngineClauseContext;
    dictionaryPrimaryKeyClause(): DictionaryPrimaryKeyClauseContext;
    dictionaryArgumentExpression(): DictionaryArgumentExpressionContext;
    sourceClause(): SourceClauseContext;
    lifetimeClause(): LifetimeClauseContext;
    layoutClause(): LayoutClauseContext;
    rangeClause(): RangeClauseContext;
    dictionarySettingsClause(): DictionarySettingsClauseContext;
    clusterClause(): ClusterClauseContext;
    uuidClause(): UuidClauseContext;
    destinationClause(): DestinationClauseContext;
    subqueryClause(): SubqueryClauseContext;
    tableSchemaClause(): TableSchemaClauseContext;
    engineClause(): EngineClauseContext;
    partitionByClause(): PartitionByClauseContext;
    primaryKeyClause(): PrimaryKeyClauseContext;
    sampleByClause(): SampleByClauseContext;
    ttlClause(): TtlClauseContext;
    engineExpression(): EngineExpressionContext;
    tableElementExpression(): TableElementExpressionContext;
    tableColumnDefinition(): TableColumnDefinitionContext;
    tableColumnPropertyExpression(): TableColumnPropertyExpressionContext;
    tableIndexDefinition(): TableIndexDefinitionContext;
    tableProjectionDefinition(): TableProjectionDefinitionContext;
    codecExpression(): CodecExpressionContext;
    codecArgExpression(): CodecArgExpressionContext;
    ttlExpression(): TtlExpressionContext;
    describeStatement(): DescribeStatementContext;
    dropStatement(): DropStatementContext;
    existsStatement(): ExistsStatementContext;
    explainStatement(): ExplainStatementContext;
    insertStatement(): InsertStatementContext;
    columnsClause(): ColumnsClauseContext;
    dataClause(): DataClauseContext;
    valuesStatement(): ValuesStatementContext;
    killStatement(): KillStatementContext;
    optimizeStatement(): OptimizeStatementContext;
    renameStatement(): RenameStatementContext;
    projectionSelectStatement(): ProjectionSelectStatementContext;
    selectUnionStatement(): SelectUnionStatementContext;
    selectStatementWithParentheses(): SelectStatementWithParenthesesContext;
    selectStatement(): SelectStatementContext;
    withClause(): WithClauseContext;
    topClause(): TopClauseContext;
    fromClause(): FromClauseContext;
    arrayJoinClause(): ArrayJoinClauseContext;
    windowClause(): WindowClauseContext;
    prewhereClause(): PrewhereClauseContext;
    whereClause(): WhereClauseContext;
    groupByClause(): GroupByClauseContext;
    havingClause(): HavingClauseContext;
    orderByClause(): OrderByClauseContext;
    projectionOrderByClause(): ProjectionOrderByClauseContext;
    limitByClause(): LimitByClauseContext;
    limitClause(): LimitClauseContext;
    settingsClause(): SettingsClauseContext;
    joinExpression(): JoinExpressionContext;
    joinExpression(_p: number): JoinExpressionContext;
    joinOperator(): JoinOperatorContext;
    joinOperatorCross(): JoinOperatorCrossContext;
    joinConstraintClause(): JoinConstraintClauseContext;
    sampleClause(): SampleClauseContext;
    limitExpression(): LimitExpressionContext;
    orderExpressionList(): OrderExpressionListContext;
    orderExpression(): OrderExpressionContext;
    ratioExpression(): RatioExpressionContext;
    settingExpressionList(): SettingExpressionListContext;
    settingExpression(): SettingExpressionContext;
    windowExpression(): WindowExpressionContext;
    windowPartitionByClause(): WindowPartitionByClauseContext;
    windowOrderByClause(): WindowOrderByClauseContext;
    windowFrameClause(): WindowFrameClauseContext;
    windowFrameExtend(): WindowFrameExtendContext;
    windowFrameBound(): WindowFrameBoundContext;
    setStatement(): SetStatementContext;
    showStatement(): ShowStatementContext;
    systemStatement(): SystemStatementContext;
    truncateStatement(): TruncateStatementContext;
    useStatement(): UseStatementContext;
    watchStatement(): WatchStatementContext;
    columnTypeExpression(): ColumnTypeExpressionContext;
    columnExpressionList(): ColumnExpressionListContext;
    columnsExpression(): ColumnsExpressionContext;
    columnExpression(): ColumnExpressionContext;
    columnExpression(_p: number): ColumnExpressionContext;
    columnArgumentList(): ColumnArgumentListContext;
    columnArgumentExpression(): ColumnArgumentExpressionContext;
    columnLambdaExpression(): ColumnLambdaExpressionContext;
    columnIdentifier(): ColumnIdentifierContext;
    tableExpression(): TableExpressionContext;
    tableExpression(_p: number): TableExpressionContext;
    tableFunctionExpression(): TableFunctionExpressionContext;
    tableIdentifier(): TableIdentifierContext;
    tableArgList(): TableArgListContext;
    tableArgExpression(): TableArgExpressionContext;
    databaseIdentifier(): DatabaseIdentifierContext;
    floatingLiteral(): FloatingLiteralContext;
    numberLiteral(): NumberLiteralContext;
    literal(): LiteralContext;
    interval(): IntervalContext;
    keyword(): KeywordContext;
    keywordForAlias(): KeywordForAliasContext;
    alias(): AliasContext;
    identifier(): IdentifierContext;
    identifierOrNull(): IdentifierOrNullContext;
    enumValue(): EnumValueContext;
    sempred(localContext: antlr.ParserRuleContext | null, ruleIndex: number, predIndex: number): boolean;
    private dictionaryAttributeDefinition_sempred;
    private dictionaryEngineClause_sempred;
    private engineClause_sempred;
    private joinExpression_sempred;
    private columnExpression_sempred;
    private tableExpression_sempred;
    static readonly _serializedATN: number[];
    private static __ATN;
    static get _ATN(): antlr.ATN;
    private static readonly vocabulary;
    get vocabulary(): antlr.Vocabulary;
    private static readonly decisionsToDFA;
}
export declare class RootContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    EOF(): antlr.TerminalNode;
    statements(): StatementsContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class StatementsContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    statement(): StatementContext;
    SEMICOLON(): antlr.TerminalNode | null;
    statements(): StatementsContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class StatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    notInsertStatement(): NotInsertStatementContext | null;
    INTO(): antlr.TerminalNode | null;
    OUTFILE(): antlr.TerminalNode | null;
    STRING_LITERAL(): antlr.TerminalNode | null;
    FORMAT(): antlr.TerminalNode | null;
    identifierOrNull(): IdentifierOrNullContext | null;
    SEMICOLON(): antlr.TerminalNode | null;
    insertStatement(): InsertStatementContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class NotInsertStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    alterStatement(): AlterStatementContext | null;
    attachStatement(): AttachStatementContext | null;
    checkStatement(): CheckStatementContext | null;
    createStatement(): CreateStatementContext | null;
    describeStatement(): DescribeStatementContext | null;
    deleteStatement(): DeleteStatementContext | null;
    dropStatement(): DropStatementContext | null;
    existsStatement(): ExistsStatementContext | null;
    explainStatement(): ExplainStatementContext | null;
    killStatement(): KillStatementContext | null;
    optimizeStatement(): OptimizeStatementContext | null;
    renameStatement(): RenameStatementContext | null;
    selectUnionStatement(): SelectUnionStatementContext | null;
    setStatement(): SetStatementContext | null;
    showStatement(): ShowStatementContext | null;
    systemStatement(): SystemStatementContext | null;
    truncateStatement(): TruncateStatementContext | null;
    useStatement(): UseStatementContext | null;
    watchStatement(): WatchStatementContext | null;
    selectStatement(): SelectStatementContext | null;
    commonTableExpressionStatement(): CommonTableExpressionStatementContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class CommonTableExpressionStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    WITH(): antlr.TerminalNode;
    namedQuery(): NamedQueryContext[];
    namedQuery(i: number): NamedQueryContext | null;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class NamedQueryContext extends antlr.ParserRuleContext {
    _name?: IdentifierContext;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    AS(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode;
    notInsertStatement(): NotInsertStatementContext;
    RPAREN(): antlr.TerminalNode;
    identifier(): IdentifierContext;
    columnAliases(): ColumnAliasesContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnAliasesContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LPAREN(): antlr.TerminalNode;
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext | null;
    RPAREN(): antlr.TerminalNode;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: AlterStatementContext): void;
}
export declare class AlterTableStatementContext extends AlterStatementContext {
    constructor(ctx: AlterStatementContext);
    ALTER(): antlr.TerminalNode;
    TABLE(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    alterTableClause(): AlterTableClauseContext[];
    alterTableClause(i: number): AlterTableClauseContext | null;
    clusterClause(): ClusterClauseContext | null;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: AlterTableClauseContext): void;
}
export declare class AlterTableClauseReplaceContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    REPLACE(): antlr.TerminalNode;
    partitionClause(): PartitionClauseContext;
    FROM(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseModifyOrderByContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    MODIFY(): antlr.TerminalNode;
    ORDER(): antlr.TerminalNode;
    BY(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseUpdateContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    UPDATE(): antlr.TerminalNode;
    assignmentExpressionList(): AssignmentExpressionListContext;
    whereClause(): WhereClauseContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseClearProjectionContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    CLEAR(): antlr.TerminalNode;
    PROJECTION(): antlr.TerminalNode;
    columnIdentifier(): ColumnIdentifierContext;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    IN(): antlr.TerminalNode | null;
    partitionClause(): PartitionClauseContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseModifyRemoveContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    MODIFY(): antlr.TerminalNode;
    COLUMN(): antlr.TerminalNode;
    columnIdentifier(): ColumnIdentifierContext;
    REMOVE(): antlr.TerminalNode;
    tableColumnPropertyType(): TableColumnPropertyTypeContext;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseDeleteContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    DELETE(): antlr.TerminalNode;
    WHERE(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseCommentContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    COMMENT(): antlr.TerminalNode;
    COLUMN(): antlr.TerminalNode;
    columnIdentifier(): ColumnIdentifierContext;
    STRING_LITERAL(): antlr.TerminalNode;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseDropColumnContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    DROP(): antlr.TerminalNode;
    COLUMN(): antlr.TerminalNode;
    columnIdentifier(): ColumnIdentifierContext;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseDetachContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    DETACH(): antlr.TerminalNode;
    partitionClause(): PartitionClauseContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseAddIndexContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    ADD(): antlr.TerminalNode;
    INDEX(): antlr.TerminalNode;
    tableIndexDefinition(): TableIndexDefinitionContext;
    IF(): antlr.TerminalNode | null;
    NOT(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    AFTER(): antlr.TerminalNode | null;
    columnIdentifier(): ColumnIdentifierContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseDropPartitionContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    DROP(): antlr.TerminalNode;
    partitionClause(): PartitionClauseContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseMaterializeIndexContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    MATERIALIZE(): antlr.TerminalNode;
    INDEX(): antlr.TerminalNode;
    columnIdentifier(): ColumnIdentifierContext;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    IN(): antlr.TerminalNode | null;
    partitionClause(): PartitionClauseContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseMaterializeProjectionContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    MATERIALIZE(): antlr.TerminalNode;
    PROJECTION(): antlr.TerminalNode;
    columnIdentifier(): ColumnIdentifierContext;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    IN(): antlr.TerminalNode | null;
    partitionClause(): PartitionClauseContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseMovePartitionContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    MOVE(): antlr.TerminalNode;
    partitionClause(): PartitionClauseContext;
    TO(): antlr.TerminalNode | null;
    DISK(): antlr.TerminalNode | null;
    STRING_LITERAL(): antlr.TerminalNode | null;
    VOLUME(): antlr.TerminalNode | null;
    TABLE(): antlr.TerminalNode | null;
    tableIdentifier(): TableIdentifierContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseRenameContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    RENAME(): antlr.TerminalNode;
    COLUMN(): antlr.TerminalNode;
    columnIdentifier(): ColumnIdentifierContext[];
    columnIdentifier(i: number): ColumnIdentifierContext | null;
    TO(): antlr.TerminalNode;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseFreezePartitionContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    FREEZE(): antlr.TerminalNode;
    partitionClause(): PartitionClauseContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseClearColumnContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    CLEAR(): antlr.TerminalNode;
    COLUMN(): antlr.TerminalNode;
    columnIdentifier(): ColumnIdentifierContext;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    IN(): antlr.TerminalNode | null;
    partitionClause(): PartitionClauseContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseModifyContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    MODIFY(): antlr.TerminalNode;
    COLUMN(): antlr.TerminalNode;
    tableColumnDefinition(): TableColumnDefinitionContext;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseClearIndexContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    CLEAR(): antlr.TerminalNode;
    INDEX(): antlr.TerminalNode;
    columnIdentifier(): ColumnIdentifierContext;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    IN(): antlr.TerminalNode | null;
    partitionClause(): PartitionClauseContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseRemoveTTLContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    REMOVE(): antlr.TerminalNode;
    TTL(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseModifyCodecContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    MODIFY(): antlr.TerminalNode;
    COLUMN(): antlr.TerminalNode;
    columnIdentifier(): ColumnIdentifierContext;
    codecExpression(): CodecExpressionContext;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseAttachContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    ATTACH(): antlr.TerminalNode;
    partitionClause(): PartitionClauseContext;
    FROM(): antlr.TerminalNode | null;
    tableIdentifier(): TableIdentifierContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseDropProjectionContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    DROP(): antlr.TerminalNode;
    PROJECTION(): antlr.TerminalNode;
    columnIdentifier(): ColumnIdentifierContext;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseDropIndexContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    DROP(): antlr.TerminalNode;
    INDEX(): antlr.TerminalNode;
    columnIdentifier(): ColumnIdentifierContext;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseModifyCommentContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    MODIFY(): antlr.TerminalNode;
    COLUMN(): antlr.TerminalNode;
    columnIdentifier(): ColumnIdentifierContext;
    COMMENT(): antlr.TerminalNode;
    STRING_LITERAL(): antlr.TerminalNode;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseModifyTTLContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    MODIFY(): antlr.TerminalNode;
    ttlClause(): TtlClauseContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseAddProjectionContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    ADD(): antlr.TerminalNode;
    PROJECTION(): antlr.TerminalNode;
    tableProjectionDefinition(): TableProjectionDefinitionContext;
    IF(): antlr.TerminalNode | null;
    NOT(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    AFTER(): antlr.TerminalNode | null;
    columnIdentifier(): ColumnIdentifierContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AlterTableClauseAddColumnContext extends AlterTableClauseContext {
    constructor(ctx: AlterTableClauseContext);
    ADD(): antlr.TerminalNode;
    COLUMN(): antlr.TerminalNode;
    tableColumnDefinition(): TableColumnDefinitionContext;
    IF(): antlr.TerminalNode | null;
    NOT(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    AFTER(): antlr.TerminalNode | null;
    columnIdentifier(): ColumnIdentifierContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AssignmentExpressionListContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    assignmentExpression(): AssignmentExpressionContext[];
    assignmentExpression(i: number): AssignmentExpressionContext | null;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AssignmentExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    columnIdentifier(): ColumnIdentifierContext;
    EQ_SINGLE(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableColumnPropertyTypeContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    ALIAS(): antlr.TerminalNode | null;
    CODEC(): antlr.TerminalNode | null;
    COMMENT(): antlr.TerminalNode | null;
    DEFAULT(): antlr.TerminalNode | null;
    MATERIALIZED(): antlr.TerminalNode | null;
    TTL(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class PartitionClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    PARTITION(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext | null;
    ID(): antlr.TerminalNode | null;
    STRING_LITERAL(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AttachStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: AttachStatementContext): void;
}
export declare class AttachDictionaryStatementContext extends AttachStatementContext {
    constructor(ctx: AttachStatementContext);
    ATTACH(): antlr.TerminalNode;
    DICTIONARY(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    clusterClause(): ClusterClauseContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class CheckStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    CHECK(): antlr.TerminalNode;
    TABLE(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    partitionClause(): PartitionClauseContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class DeleteStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    DELETE(): antlr.TerminalNode;
    FROM(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    clusterClause(): ClusterClauseContext | null;
    whereClause(): WhereClauseContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class CreateTableStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    TABLE(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    ATTACH(): antlr.TerminalNode | null;
    CREATE(): antlr.TerminalNode | null;
    REPLACE(): antlr.TerminalNode | null;
    TEMPORARY(): antlr.TerminalNode | null;
    IF(): antlr.TerminalNode | null;
    NOT(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    uuidClause(): UuidClauseContext | null;
    clusterClause(): ClusterClauseContext | null;
    tableSchemaClause(): TableSchemaClauseContext | null;
    engineClause(): EngineClauseContext | null;
    subqueryClause(): SubqueryClauseContext | null;
    OR(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class CreateDatabaseStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    DATABASE(): antlr.TerminalNode;
    identifier(): IdentifierContext;
    engineExpression(): EngineExpressionContext;
    ATTACH(): antlr.TerminalNode | null;
    CREATE(): antlr.TerminalNode | null;
    IF(): antlr.TerminalNode | null;
    NOT(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    clusterClause(): ClusterClauseContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class CreateDictionaryStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    DICTIONARY(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    dictionarySchemaClause(): DictionarySchemaClauseContext;
    dictionaryEngineClause(): DictionaryEngineClauseContext;
    ATTACH(): antlr.TerminalNode | null;
    CREATE(): antlr.TerminalNode | null;
    REPLACE(): antlr.TerminalNode | null;
    IF(): antlr.TerminalNode | null;
    NOT(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    uuidClause(): UuidClauseContext | null;
    clusterClause(): ClusterClauseContext | null;
    OR(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class CreateLiveViewStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LIVE(): antlr.TerminalNode;
    VIEW(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    subqueryClause(): SubqueryClauseContext;
    ATTACH(): antlr.TerminalNode | null;
    CREATE(): antlr.TerminalNode | null;
    IF(): antlr.TerminalNode | null;
    NOT(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    uuidClause(): UuidClauseContext | null;
    clusterClause(): ClusterClauseContext | null;
    WITH(): antlr.TerminalNode | null;
    TIMEOUT(): antlr.TerminalNode | null;
    destinationClause(): DestinationClauseContext | null;
    tableSchemaClause(): TableSchemaClauseContext | null;
    DECIMAL_LITERAL(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class CreateMaterializedViewStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    MATERIALIZED(): antlr.TerminalNode;
    VIEW(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    subqueryClause(): SubqueryClauseContext;
    ATTACH(): antlr.TerminalNode | null;
    CREATE(): antlr.TerminalNode | null;
    destinationClause(): DestinationClauseContext | null;
    engineClause(): EngineClauseContext | null;
    IF(): antlr.TerminalNode | null;
    NOT(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    uuidClause(): UuidClauseContext | null;
    clusterClause(): ClusterClauseContext | null;
    tableSchemaClause(): TableSchemaClauseContext | null;
    POPULATE(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class CreateViewStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    VIEW(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    subqueryClause(): SubqueryClauseContext;
    ATTACH(): antlr.TerminalNode | null;
    CREATE(): antlr.TerminalNode | null;
    OR(): antlr.TerminalNode | null;
    REPLACE(): antlr.TerminalNode | null;
    IF(): antlr.TerminalNode | null;
    NOT(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    uuidClause(): UuidClauseContext | null;
    clusterClause(): ClusterClauseContext | null;
    tableSchemaClause(): TableSchemaClauseContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class CreateStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    createDatabaseStatement(): CreateDatabaseStatementContext | null;
    createDictionaryStatement(): CreateDictionaryStatementContext | null;
    createLiveViewStatement(): CreateLiveViewStatementContext | null;
    createMaterializedViewStatement(): CreateMaterializedViewStatementContext | null;
    createTableStatement(): CreateTableStatementContext | null;
    createViewStatement(): CreateViewStatementContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class DictionarySchemaClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LPAREN(): antlr.TerminalNode;
    dictionaryAttributeDefinition(): DictionaryAttributeDefinitionContext[];
    dictionaryAttributeDefinition(i: number): DictionaryAttributeDefinitionContext | null;
    RPAREN(): antlr.TerminalNode;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class DictionaryAttributeDefinitionContext extends antlr.ParserRuleContext {
    attrs: Set<string>;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    identifier(): IdentifierContext;
    columnTypeExpression(): ColumnTypeExpressionContext;
    DEFAULT(): antlr.TerminalNode[];
    DEFAULT(i: number): antlr.TerminalNode | null;
    literal(): LiteralContext[];
    literal(i: number): LiteralContext | null;
    EXPRESSION(): antlr.TerminalNode[];
    EXPRESSION(i: number): antlr.TerminalNode | null;
    columnExpression(): ColumnExpressionContext[];
    columnExpression(i: number): ColumnExpressionContext | null;
    HIERARCHICAL(): antlr.TerminalNode[];
    HIERARCHICAL(i: number): antlr.TerminalNode | null;
    INJECTIVE(): antlr.TerminalNode[];
    INJECTIVE(i: number): antlr.TerminalNode | null;
    IS_OBJECT_ID(): antlr.TerminalNode[];
    IS_OBJECT_ID(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class DictionaryEngineClauseContext extends antlr.ParserRuleContext {
    clauses: Set<string>;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    dictionaryPrimaryKeyClause(): DictionaryPrimaryKeyClauseContext | null;
    sourceClause(): SourceClauseContext[];
    sourceClause(i: number): SourceClauseContext | null;
    lifetimeClause(): LifetimeClauseContext[];
    lifetimeClause(i: number): LifetimeClauseContext | null;
    layoutClause(): LayoutClauseContext[];
    layoutClause(i: number): LayoutClauseContext | null;
    rangeClause(): RangeClauseContext[];
    rangeClause(i: number): RangeClauseContext | null;
    dictionarySettingsClause(): DictionarySettingsClauseContext[];
    dictionarySettingsClause(i: number): DictionarySettingsClauseContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class DictionaryPrimaryKeyClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    PRIMARY(): antlr.TerminalNode;
    KEY(): antlr.TerminalNode;
    columnExpressionList(): ColumnExpressionListContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class DictionaryArgumentExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext | null;
    literal(): LiteralContext | null;
    LPAREN(): antlr.TerminalNode | null;
    RPAREN(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class SourceClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    SOURCE(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode[];
    LPAREN(i: number): antlr.TerminalNode | null;
    identifier(): IdentifierContext;
    RPAREN(): antlr.TerminalNode[];
    RPAREN(i: number): antlr.TerminalNode | null;
    dictionaryArgumentExpression(): DictionaryArgumentExpressionContext[];
    dictionaryArgumentExpression(i: number): DictionaryArgumentExpressionContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class LifetimeClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LIFETIME(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode;
    RPAREN(): antlr.TerminalNode;
    DECIMAL_LITERAL(): antlr.TerminalNode[];
    DECIMAL_LITERAL(i: number): antlr.TerminalNode | null;
    MIN(): antlr.TerminalNode | null;
    MAX(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class LayoutClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LAYOUT(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode[];
    LPAREN(i: number): antlr.TerminalNode | null;
    identifier(): IdentifierContext;
    RPAREN(): antlr.TerminalNode[];
    RPAREN(i: number): antlr.TerminalNode | null;
    dictionaryArgumentExpression(): DictionaryArgumentExpressionContext[];
    dictionaryArgumentExpression(i: number): DictionaryArgumentExpressionContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class RangeClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    RANGE(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode;
    RPAREN(): antlr.TerminalNode;
    MIN(): antlr.TerminalNode | null;
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext | null;
    MAX(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class DictionarySettingsClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    SETTINGS(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode;
    settingExpressionList(): SettingExpressionListContext;
    RPAREN(): antlr.TerminalNode;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ClusterClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    ON(): antlr.TerminalNode;
    CLUSTER(): antlr.TerminalNode;
    identifier(): IdentifierContext | null;
    STRING_LITERAL(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class UuidClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    UUID(): antlr.TerminalNode;
    STRING_LITERAL(): antlr.TerminalNode;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class DestinationClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    TO(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class SubqueryClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    AS(): antlr.TerminalNode;
    selectUnionStatement(): SelectUnionStatementContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableSchemaClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: TableSchemaClauseContext): void;
}
export declare class SchemaAsTableClauseContext extends TableSchemaClauseContext {
    constructor(ctx: TableSchemaClauseContext);
    AS(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class SchemaAsFunctionClauseContext extends TableSchemaClauseContext {
    constructor(ctx: TableSchemaClauseContext);
    AS(): antlr.TerminalNode;
    tableFunctionExpression(): TableFunctionExpressionContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class SchemaDescriptionClauseContext extends TableSchemaClauseContext {
    constructor(ctx: TableSchemaClauseContext);
    LPAREN(): antlr.TerminalNode;
    tableElementExpression(): TableElementExpressionContext[];
    tableElementExpression(i: number): TableElementExpressionContext | null;
    RPAREN(): antlr.TerminalNode;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class EngineClauseContext extends antlr.ParserRuleContext {
    clauses: Set<string>;
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    engineExpression(): EngineExpressionContext;
    orderByClause(): OrderByClauseContext[];
    orderByClause(i: number): OrderByClauseContext | null;
    partitionByClause(): PartitionByClauseContext[];
    partitionByClause(i: number): PartitionByClauseContext | null;
    primaryKeyClause(): PrimaryKeyClauseContext[];
    primaryKeyClause(i: number): PrimaryKeyClauseContext | null;
    sampleByClause(): SampleByClauseContext[];
    sampleByClause(i: number): SampleByClauseContext | null;
    ttlClause(): TtlClauseContext[];
    ttlClause(i: number): TtlClauseContext | null;
    settingsClause(): SettingsClauseContext[];
    settingsClause(i: number): SettingsClauseContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class PartitionByClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    PARTITION(): antlr.TerminalNode;
    BY(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class PrimaryKeyClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    PRIMARY(): antlr.TerminalNode;
    KEY(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class SampleByClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    SAMPLE(): antlr.TerminalNode;
    BY(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TtlClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    TTL(): antlr.TerminalNode;
    ttlExpression(): TtlExpressionContext[];
    ttlExpression(i: number): TtlExpressionContext | null;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class EngineExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    ENGINE(): antlr.TerminalNode;
    identifierOrNull(): IdentifierOrNullContext;
    EQ_SINGLE(): antlr.TerminalNode | null;
    LPAREN(): antlr.TerminalNode | null;
    RPAREN(): antlr.TerminalNode | null;
    columnExpressionList(): ColumnExpressionListContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableElementExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: TableElementExpressionContext): void;
}
export declare class TableElementExpressionColumnContext extends TableElementExpressionContext {
    constructor(ctx: TableElementExpressionContext);
    tableColumnDefinition(): TableColumnDefinitionContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableElementExpressionConstraintContext extends TableElementExpressionContext {
    constructor(ctx: TableElementExpressionContext);
    CONSTRAINT(): antlr.TerminalNode;
    identifier(): IdentifierContext;
    CHECK(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableElementExpressionIndexContext extends TableElementExpressionContext {
    constructor(ctx: TableElementExpressionContext);
    INDEX(): antlr.TerminalNode;
    tableIndexDefinition(): TableIndexDefinitionContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableElementExpressionProjectionContext extends TableElementExpressionContext {
    constructor(ctx: TableElementExpressionContext);
    PROJECTION(): antlr.TerminalNode;
    tableProjectionDefinition(): TableProjectionDefinitionContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableColumnDefinitionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    columnIdentifier(): ColumnIdentifierContext;
    columnTypeExpression(): ColumnTypeExpressionContext | null;
    tableColumnPropertyExpression(): TableColumnPropertyExpressionContext | null;
    COMMENT(): antlr.TerminalNode | null;
    STRING_LITERAL(): antlr.TerminalNode | null;
    codecExpression(): CodecExpressionContext | null;
    TTL(): antlr.TerminalNode | null;
    columnExpression(): ColumnExpressionContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableColumnPropertyExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    columnExpression(): ColumnExpressionContext;
    DEFAULT(): antlr.TerminalNode | null;
    MATERIALIZED(): antlr.TerminalNode | null;
    ALIAS(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableIndexDefinitionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    columnIdentifier(): ColumnIdentifierContext;
    columnExpression(): ColumnExpressionContext;
    TYPE(): antlr.TerminalNode;
    columnTypeExpression(): ColumnTypeExpressionContext;
    GRANULARITY(): antlr.TerminalNode;
    DECIMAL_LITERAL(): antlr.TerminalNode;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableProjectionDefinitionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    columnIdentifier(): ColumnIdentifierContext;
    projectionSelectStatement(): ProjectionSelectStatementContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class CodecExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    CODEC(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode;
    codecArgExpression(): CodecArgExpressionContext[];
    codecArgExpression(i: number): CodecArgExpressionContext | null;
    RPAREN(): antlr.TerminalNode;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class CodecArgExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    identifier(): IdentifierContext;
    LPAREN(): antlr.TerminalNode | null;
    RPAREN(): antlr.TerminalNode | null;
    columnExpressionList(): ColumnExpressionListContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TtlExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    columnExpression(): ColumnExpressionContext;
    DELETE(): antlr.TerminalNode | null;
    TO(): antlr.TerminalNode | null;
    DISK(): antlr.TerminalNode | null;
    STRING_LITERAL(): antlr.TerminalNode | null;
    VOLUME(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class DescribeStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    tableExpression(): TableExpressionContext;
    DESCRIBE(): antlr.TerminalNode | null;
    DESC(): antlr.TerminalNode | null;
    TABLE(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class DropStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: DropStatementContext): void;
}
export declare class DropDatabaseStatementContext extends DropStatementContext {
    constructor(ctx: DropStatementContext);
    DATABASE(): antlr.TerminalNode;
    databaseIdentifier(): DatabaseIdentifierContext;
    DETACH(): antlr.TerminalNode | null;
    DROP(): antlr.TerminalNode | null;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    clusterClause(): ClusterClauseContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class DropTableStatementContext extends DropStatementContext {
    constructor(ctx: DropStatementContext);
    tableIdentifier(): TableIdentifierContext;
    DETACH(): antlr.TerminalNode | null;
    DROP(): antlr.TerminalNode | null;
    DICTIONARY(): antlr.TerminalNode | null;
    TABLE(): antlr.TerminalNode | null;
    VIEW(): antlr.TerminalNode | null;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    clusterClause(): ClusterClauseContext | null;
    NO(): antlr.TerminalNode | null;
    DELAY(): antlr.TerminalNode | null;
    TEMPORARY(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ExistsStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: ExistsStatementContext): void;
}
export declare class ExistsDatabaseStatementContext extends ExistsStatementContext {
    constructor(ctx: ExistsStatementContext);
    EXISTS(): antlr.TerminalNode;
    DATABASE(): antlr.TerminalNode;
    databaseIdentifier(): DatabaseIdentifierContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ExistsTableStatementContext extends ExistsStatementContext {
    constructor(ctx: ExistsStatementContext);
    EXISTS(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    DICTIONARY(): antlr.TerminalNode | null;
    TABLE(): antlr.TerminalNode | null;
    VIEW(): antlr.TerminalNode | null;
    TEMPORARY(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ExplainStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: ExplainStatementContext): void;
}
export declare class ExplainASTStatementContext extends ExplainStatementContext {
    constructor(ctx: ExplainStatementContext);
    EXPLAIN(): antlr.TerminalNode;
    AST(): antlr.TerminalNode;
    notInsertStatement(): NotInsertStatementContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ExplainQueryTreeStatementContext extends ExplainStatementContext {
    constructor(ctx: ExplainStatementContext);
    EXPLAIN(): antlr.TerminalNode;
    QUERY(): antlr.TerminalNode;
    TREE(): antlr.TerminalNode;
    notInsertStatement(): NotInsertStatementContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ExplainPlanStatementContext extends ExplainStatementContext {
    constructor(ctx: ExplainStatementContext);
    EXPLAIN(): antlr.TerminalNode;
    PLAN(): antlr.TerminalNode;
    notInsertStatement(): NotInsertStatementContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ExplainDefaultStatementContext extends ExplainStatementContext {
    constructor(ctx: ExplainStatementContext);
    EXPLAIN(): antlr.TerminalNode;
    notInsertStatement(): NotInsertStatementContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ExplainEstimateStatementContext extends ExplainStatementContext {
    constructor(ctx: ExplainStatementContext);
    EXPLAIN(): antlr.TerminalNode;
    ESTIMATE(): antlr.TerminalNode;
    notInsertStatement(): NotInsertStatementContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ExplainSyntaxStatementContext extends ExplainStatementContext {
    constructor(ctx: ExplainStatementContext);
    EXPLAIN(): antlr.TerminalNode;
    SYNTAX(): antlr.TerminalNode;
    notInsertStatement(): NotInsertStatementContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ExplainPipelineStatementContext extends ExplainStatementContext {
    constructor(ctx: ExplainStatementContext);
    EXPLAIN(): antlr.TerminalNode;
    PIPELINE(): antlr.TerminalNode;
    notInsertStatement(): NotInsertStatementContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class InsertStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    INSERT(): antlr.TerminalNode;
    INTO(): antlr.TerminalNode;
    dataClause(): DataClauseContext;
    tableIdentifier(): TableIdentifierContext | null;
    FUNCTION(): antlr.TerminalNode | null;
    tableFunctionExpression(): TableFunctionExpressionContext | null;
    TABLE(): antlr.TerminalNode | null;
    columnsClause(): ColumnsClauseContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnsClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LPAREN(): antlr.TerminalNode;
    columnIdentifier(): ColumnIdentifierContext[];
    columnIdentifier(i: number): ColumnIdentifierContext | null;
    RPAREN(): antlr.TerminalNode;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class DataClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: DataClauseContext): void;
}
export declare class DataClauseValuesContext extends DataClauseContext {
    constructor(ctx: DataClauseContext);
    valuesStatement(): ValuesStatementContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class DataClauseFormatContext extends DataClauseContext {
    constructor(ctx: DataClauseContext);
    FORMAT(): antlr.TerminalNode;
    identifier(): IdentifierContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class DataClauseSelectContext extends DataClauseContext {
    constructor(ctx: DataClauseContext);
    selectUnionStatement(): SelectUnionStatementContext;
    EOF(): antlr.TerminalNode;
    SEMICOLON(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ValuesStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    VALUES(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode[];
    LPAREN(i: number): antlr.TerminalNode | null;
    RPAREN(): antlr.TerminalNode[];
    RPAREN(i: number): antlr.TerminalNode | null;
    literal(): LiteralContext[];
    literal(i: number): LiteralContext | null;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class KillStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: KillStatementContext): void;
}
export declare class KillMutationStatementContext extends KillStatementContext {
    constructor(ctx: KillStatementContext);
    KILL(): antlr.TerminalNode;
    MUTATION(): antlr.TerminalNode;
    whereClause(): WhereClauseContext;
    clusterClause(): ClusterClauseContext | null;
    SYNC(): antlr.TerminalNode | null;
    ASYNC(): antlr.TerminalNode | null;
    TEST(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class OptimizeStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    OPTIMIZE(): antlr.TerminalNode;
    TABLE(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    clusterClause(): ClusterClauseContext | null;
    partitionClause(): PartitionClauseContext | null;
    FINAL(): antlr.TerminalNode | null;
    DEDUPLICATE(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class RenameStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    RENAME(): antlr.TerminalNode;
    TABLE(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext[];
    tableIdentifier(i: number): TableIdentifierContext | null;
    TO(): antlr.TerminalNode[];
    TO(i: number): antlr.TerminalNode | null;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    clusterClause(): ClusterClauseContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ProjectionSelectStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LPAREN(): antlr.TerminalNode;
    SELECT(): antlr.TerminalNode;
    columnExpressionList(): ColumnExpressionListContext;
    RPAREN(): antlr.TerminalNode;
    withClause(): WithClauseContext | null;
    groupByClause(): GroupByClauseContext | null;
    projectionOrderByClause(): ProjectionOrderByClauseContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class SelectUnionStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    selectStatementWithParentheses(): SelectStatementWithParenthesesContext[];
    selectStatementWithParentheses(i: number): SelectStatementWithParenthesesContext | null;
    UNION(): antlr.TerminalNode[];
    UNION(i: number): antlr.TerminalNode | null;
    ALL(): antlr.TerminalNode[];
    ALL(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class SelectStatementWithParenthesesContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    selectStatement(): SelectStatementContext | null;
    LPAREN(): antlr.TerminalNode | null;
    selectUnionStatement(): SelectUnionStatementContext | null;
    RPAREN(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class SelectStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    SELECT(): antlr.TerminalNode;
    columnExpressionList(): ColumnExpressionListContext;
    withClause(): WithClauseContext | null;
    DISTINCT(): antlr.TerminalNode | null;
    topClause(): TopClauseContext | null;
    fromClause(): FromClauseContext | null;
    arrayJoinClause(): ArrayJoinClauseContext | null;
    windowClause(): WindowClauseContext | null;
    prewhereClause(): PrewhereClauseContext | null;
    whereClause(): WhereClauseContext | null;
    groupByClause(): GroupByClauseContext | null;
    WITH(): antlr.TerminalNode[];
    WITH(i: number): antlr.TerminalNode | null;
    TOTALS(): antlr.TerminalNode | null;
    havingClause(): HavingClauseContext | null;
    orderByClause(): OrderByClauseContext | null;
    limitByClause(): LimitByClauseContext | null;
    limitClause(): LimitClauseContext | null;
    settingsClause(): SettingsClauseContext | null;
    CUBE(): antlr.TerminalNode | null;
    ROLLUP(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class WithClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    WITH(): antlr.TerminalNode;
    columnExpressionList(): ColumnExpressionListContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TopClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    TOP(): antlr.TerminalNode;
    DECIMAL_LITERAL(): antlr.TerminalNode;
    WITH(): antlr.TerminalNode | null;
    TIES(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class FromClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    FROM(): antlr.TerminalNode;
    joinExpression(): JoinExpressionContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ArrayJoinClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    ARRAY(): antlr.TerminalNode;
    JOIN(): antlr.TerminalNode;
    columnExpressionList(): ColumnExpressionListContext;
    LEFT(): antlr.TerminalNode | null;
    INNER(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class WindowClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    WINDOW(): antlr.TerminalNode;
    identifier(): IdentifierContext;
    AS(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode;
    windowExpression(): WindowExpressionContext;
    RPAREN(): antlr.TerminalNode;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class PrewhereClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    PREWHERE(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class WhereClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    WHERE(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class GroupByClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    GROUP(): antlr.TerminalNode;
    BY(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode | null;
    columnExpressionList(): ColumnExpressionListContext | null;
    RPAREN(): antlr.TerminalNode | null;
    CUBE(): antlr.TerminalNode | null;
    ROLLUP(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class HavingClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    HAVING(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class OrderByClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    ORDER(): antlr.TerminalNode;
    BY(): antlr.TerminalNode;
    orderExpressionList(): OrderExpressionListContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ProjectionOrderByClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    ORDER(): antlr.TerminalNode;
    BY(): antlr.TerminalNode;
    columnExpressionList(): ColumnExpressionListContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class LimitByClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LIMIT(): antlr.TerminalNode;
    limitExpression(): LimitExpressionContext;
    BY(): antlr.TerminalNode;
    columnExpressionList(): ColumnExpressionListContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class LimitClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    LIMIT(): antlr.TerminalNode;
    limitExpression(): LimitExpressionContext;
    WITH(): antlr.TerminalNode | null;
    TIES(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class SettingsClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    SETTINGS(): antlr.TerminalNode;
    settingExpressionList(): SettingExpressionListContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class JoinExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: JoinExpressionContext): void;
}
export declare class JoinExpressionParensContext extends JoinExpressionContext {
    constructor(ctx: JoinExpressionContext);
    LPAREN(): antlr.TerminalNode;
    joinExpression(): JoinExpressionContext;
    RPAREN(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class JoinExpressionTableContext extends JoinExpressionContext {
    constructor(ctx: JoinExpressionContext);
    tableExpression(): TableExpressionContext;
    FINAL(): antlr.TerminalNode | null;
    sampleClause(): SampleClauseContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class JoinExpressionCrossOpContext extends JoinExpressionContext {
    constructor(ctx: JoinExpressionContext);
    joinExpression(): JoinExpressionContext[];
    joinExpression(i: number): JoinExpressionContext | null;
    joinOperatorCross(): JoinOperatorCrossContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class JoinExpressionOpContext extends JoinExpressionContext {
    constructor(ctx: JoinExpressionContext);
    joinExpression(): JoinExpressionContext[];
    joinExpression(i: number): JoinExpressionContext | null;
    JOIN(): antlr.TerminalNode;
    joinConstraintClause(): JoinConstraintClauseContext;
    joinOperator(): JoinOperatorContext | null;
    GLOBAL(): antlr.TerminalNode | null;
    LOCAL(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class JoinOperatorContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: JoinOperatorContext): void;
}
export declare class JoinOpFullContext extends JoinOperatorContext {
    constructor(ctx: JoinOperatorContext);
    FULL(): antlr.TerminalNode | null;
    OUTER(): antlr.TerminalNode | null;
    ALL(): antlr.TerminalNode | null;
    ANY(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class JoinOpInnerContext extends JoinOperatorContext {
    constructor(ctx: JoinOperatorContext);
    INNER(): antlr.TerminalNode | null;
    ALL(): antlr.TerminalNode | null;
    ANY(): antlr.TerminalNode | null;
    ASOF(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class JoinOpLeftRightContext extends JoinOperatorContext {
    constructor(ctx: JoinOperatorContext);
    LEFT(): antlr.TerminalNode | null;
    RIGHT(): antlr.TerminalNode | null;
    OUTER(): antlr.TerminalNode | null;
    SEMI(): antlr.TerminalNode | null;
    ALL(): antlr.TerminalNode | null;
    ANTI(): antlr.TerminalNode | null;
    ANY(): antlr.TerminalNode | null;
    ASOF(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class JoinOperatorCrossContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    CROSS(): antlr.TerminalNode | null;
    JOIN(): antlr.TerminalNode | null;
    GLOBAL(): antlr.TerminalNode | null;
    LOCAL(): antlr.TerminalNode | null;
    COMMA(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class JoinConstraintClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    ON(): antlr.TerminalNode | null;
    columnExpressionList(): ColumnExpressionListContext;
    USING(): antlr.TerminalNode | null;
    LPAREN(): antlr.TerminalNode | null;
    RPAREN(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class SampleClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    SAMPLE(): antlr.TerminalNode;
    ratioExpression(): RatioExpressionContext[];
    ratioExpression(i: number): RatioExpressionContext | null;
    OFFSET(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class LimitExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    columnExpression(): ColumnExpressionContext[];
    columnExpression(i: number): ColumnExpressionContext | null;
    COMMA(): antlr.TerminalNode | null;
    OFFSET(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class OrderExpressionListContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    orderExpression(): OrderExpressionContext[];
    orderExpression(i: number): OrderExpressionContext | null;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class OrderExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    columnExpression(): ColumnExpressionContext;
    NULLS(): antlr.TerminalNode | null;
    COLLATE(): antlr.TerminalNode | null;
    STRING_LITERAL(): antlr.TerminalNode | null;
    ASCENDING(): antlr.TerminalNode | null;
    DESCENDING(): antlr.TerminalNode | null;
    DESC(): antlr.TerminalNode | null;
    FIRST(): antlr.TerminalNode | null;
    LAST(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class RatioExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    numberLiteral(): NumberLiteralContext[];
    numberLiteral(i: number): NumberLiteralContext | null;
    SLASH(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class SettingExpressionListContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    settingExpression(): SettingExpressionContext[];
    settingExpression(i: number): SettingExpressionContext | null;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class SettingExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    identifier(): IdentifierContext;
    EQ_SINGLE(): antlr.TerminalNode;
    literal(): LiteralContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class WindowExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    windowPartitionByClause(): WindowPartitionByClauseContext | null;
    windowOrderByClause(): WindowOrderByClauseContext | null;
    windowFrameClause(): WindowFrameClauseContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class WindowPartitionByClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    PARTITION(): antlr.TerminalNode;
    BY(): antlr.TerminalNode;
    columnExpressionList(): ColumnExpressionListContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class WindowOrderByClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    ORDER(): antlr.TerminalNode;
    BY(): antlr.TerminalNode;
    orderExpressionList(): OrderExpressionListContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class WindowFrameClauseContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    windowFrameExtend(): WindowFrameExtendContext;
    ROWS(): antlr.TerminalNode | null;
    RANGE(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class WindowFrameExtendContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: WindowFrameExtendContext): void;
}
export declare class FrameStartContext extends WindowFrameExtendContext {
    constructor(ctx: WindowFrameExtendContext);
    windowFrameBound(): WindowFrameBoundContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class FrameBetweenContext extends WindowFrameExtendContext {
    constructor(ctx: WindowFrameExtendContext);
    BETWEEN(): antlr.TerminalNode;
    windowFrameBound(): WindowFrameBoundContext[];
    windowFrameBound(i: number): WindowFrameBoundContext | null;
    AND(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class WindowFrameBoundContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    CURRENT(): antlr.TerminalNode | null;
    ROW(): antlr.TerminalNode | null;
    UNBOUNDED(): antlr.TerminalNode | null;
    PRECEDING(): antlr.TerminalNode | null;
    FOLLOWING(): antlr.TerminalNode | null;
    numberLiteral(): NumberLiteralContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class SetStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    SET(): antlr.TerminalNode;
    settingExpressionList(): SettingExpressionListContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ShowStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: ShowStatementContext): void;
}
export declare class ShowCreateTableStatementContext extends ShowStatementContext {
    constructor(ctx: ShowStatementContext);
    SHOW(): antlr.TerminalNode;
    CREATE(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    TEMPORARY(): antlr.TerminalNode | null;
    TABLE(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ShowCreateDictionaryStatementContext extends ShowStatementContext {
    constructor(ctx: ShowStatementContext);
    SHOW(): antlr.TerminalNode;
    CREATE(): antlr.TerminalNode;
    DICTIONARY(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ShowTablesStatementContext extends ShowStatementContext {
    constructor(ctx: ShowStatementContext);
    SHOW(): antlr.TerminalNode;
    TABLES(): antlr.TerminalNode;
    TEMPORARY(): antlr.TerminalNode | null;
    databaseIdentifier(): DatabaseIdentifierContext | null;
    LIKE(): antlr.TerminalNode | null;
    STRING_LITERAL(): antlr.TerminalNode | null;
    whereClause(): WhereClauseContext | null;
    limitClause(): LimitClauseContext | null;
    FROM(): antlr.TerminalNode | null;
    IN(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ShowDictionariesStatementContext extends ShowStatementContext {
    constructor(ctx: ShowStatementContext);
    SHOW(): antlr.TerminalNode;
    DICTIONARIES(): antlr.TerminalNode;
    FROM(): antlr.TerminalNode | null;
    databaseIdentifier(): DatabaseIdentifierContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ShowCreateDatabaseStatementContext extends ShowStatementContext {
    constructor(ctx: ShowStatementContext);
    SHOW(): antlr.TerminalNode;
    CREATE(): antlr.TerminalNode;
    DATABASE(): antlr.TerminalNode;
    databaseIdentifier(): DatabaseIdentifierContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ShowDatabasesStatementContext extends ShowStatementContext {
    constructor(ctx: ShowStatementContext);
    SHOW(): antlr.TerminalNode;
    DATABASES(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class SystemStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    SYSTEM(): antlr.TerminalNode;
    FLUSH(): antlr.TerminalNode | null;
    DISTRIBUTED(): antlr.TerminalNode | null;
    tableIdentifier(): TableIdentifierContext | null;
    LOGS(): antlr.TerminalNode | null;
    RELOAD(): antlr.TerminalNode | null;
    DICTIONARIES(): antlr.TerminalNode | null;
    DICTIONARY(): antlr.TerminalNode | null;
    START(): antlr.TerminalNode | null;
    STOP(): antlr.TerminalNode | null;
    SENDS(): antlr.TerminalNode | null;
    FETCHES(): antlr.TerminalNode | null;
    MERGES(): antlr.TerminalNode | null;
    TTL(): antlr.TerminalNode | null;
    REPLICATED(): antlr.TerminalNode | null;
    SYNC(): antlr.TerminalNode | null;
    REPLICA(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TruncateStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    TRUNCATE(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    TEMPORARY(): antlr.TerminalNode | null;
    TABLE(): antlr.TerminalNode | null;
    IF(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    clusterClause(): ClusterClauseContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class UseStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    USE(): antlr.TerminalNode;
    databaseIdentifier(): DatabaseIdentifierContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class WatchStatementContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    WATCH(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext;
    EVENTS(): antlr.TerminalNode | null;
    LIMIT(): antlr.TerminalNode | null;
    DECIMAL_LITERAL(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnTypeExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: ColumnTypeExpressionContext): void;
}
export declare class ColumnTypeExpressionComplexContext extends ColumnTypeExpressionContext {
    constructor(ctx: ColumnTypeExpressionContext);
    identifier(): IdentifierContext;
    LPAREN(): antlr.TerminalNode;
    columnTypeExpression(): ColumnTypeExpressionContext[];
    columnTypeExpression(i: number): ColumnTypeExpressionContext | null;
    RPAREN(): antlr.TerminalNode;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnTypeExpressionEnumContext extends ColumnTypeExpressionContext {
    constructor(ctx: ColumnTypeExpressionContext);
    identifier(): IdentifierContext;
    LPAREN(): antlr.TerminalNode;
    enumValue(): EnumValueContext[];
    enumValue(i: number): EnumValueContext | null;
    RPAREN(): antlr.TerminalNode;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnTypeExpressionNestedContext extends ColumnTypeExpressionContext {
    constructor(ctx: ColumnTypeExpressionContext);
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext | null;
    LPAREN(): antlr.TerminalNode;
    columnTypeExpression(): ColumnTypeExpressionContext[];
    columnTypeExpression(i: number): ColumnTypeExpressionContext | null;
    RPAREN(): antlr.TerminalNode;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnTypeExpressionParamContext extends ColumnTypeExpressionContext {
    constructor(ctx: ColumnTypeExpressionContext);
    identifier(): IdentifierContext;
    LPAREN(): antlr.TerminalNode;
    RPAREN(): antlr.TerminalNode;
    columnExpressionList(): ColumnExpressionListContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnTypeExpressionSimpleContext extends ColumnTypeExpressionContext {
    constructor(ctx: ColumnTypeExpressionContext);
    identifier(): IdentifierContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionListContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    columnsExpression(): ColumnsExpressionContext[];
    columnsExpression(i: number): ColumnsExpressionContext | null;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnsExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: ColumnsExpressionContext): void;
}
export declare class ColumnsExpressionAsteriskContext extends ColumnsExpressionContext {
    constructor(ctx: ColumnsExpressionContext);
    ASTERISK(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext | null;
    DOT(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnsExpressionSubqueryContext extends ColumnsExpressionContext {
    constructor(ctx: ColumnsExpressionContext);
    LPAREN(): antlr.TerminalNode;
    selectUnionStatement(): SelectUnionStatementContext;
    RPAREN(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnsExpressionColumnContext extends ColumnsExpressionContext {
    constructor(ctx: ColumnsExpressionContext);
    columnExpression(): ColumnExpressionContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: ColumnExpressionContext): void;
}
export declare class ColumnExpressionIsNullContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    columnExpression(): ColumnExpressionContext;
    IS(): antlr.TerminalNode;
    NULL_SQL(): antlr.TerminalNode;
    NOT(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionTupleContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    LPAREN(): antlr.TerminalNode;
    columnExpressionList(): ColumnExpressionListContext;
    RPAREN(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionAndContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    columnExpression(): ColumnExpressionContext[];
    columnExpression(i: number): ColumnExpressionContext | null;
    AND(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionDateContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    DATE(): antlr.TerminalNode;
    STRING_LITERAL(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionBetweenContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    columnExpression(): ColumnExpressionContext[];
    columnExpression(i: number): ColumnExpressionContext | null;
    BETWEEN(): antlr.TerminalNode;
    AND(): antlr.TerminalNode;
    NOT(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionTrimContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    TRIM(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode;
    STRING_LITERAL(): antlr.TerminalNode;
    FROM(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    RPAREN(): antlr.TerminalNode;
    BOTH(): antlr.TerminalNode | null;
    LEADING(): antlr.TerminalNode | null;
    TRAILING(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionNotContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    NOT(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionSubstringContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    SUBSTRING(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext[];
    columnExpression(i: number): ColumnExpressionContext | null;
    FROM(): antlr.TerminalNode;
    RPAREN(): antlr.TerminalNode;
    FOR(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionCaseContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    CASE(): antlr.TerminalNode;
    END(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext[];
    columnExpression(i: number): ColumnExpressionContext | null;
    WHEN(): antlr.TerminalNode[];
    WHEN(i: number): antlr.TerminalNode | null;
    THEN(): antlr.TerminalNode[];
    THEN(i: number): antlr.TerminalNode | null;
    ELSE(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionIdentifierContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    columnIdentifier(): ColumnIdentifierContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionArrayAccessContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    columnExpression(): ColumnExpressionContext[];
    columnExpression(i: number): ColumnExpressionContext | null;
    LBRACKET(): antlr.TerminalNode;
    RBRACKET(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionFunctionContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    identifier(): IdentifierContext;
    LPAREN(): antlr.TerminalNode[];
    LPAREN(i: number): antlr.TerminalNode | null;
    RPAREN(): antlr.TerminalNode[];
    RPAREN(i: number): antlr.TerminalNode | null;
    DISTINCT(): antlr.TerminalNode | null;
    columnArgumentList(): ColumnArgumentListContext | null;
    columnExpressionList(): ColumnExpressionListContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionAsteriskContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    ASTERISK(): antlr.TerminalNode;
    tableIdentifier(): TableIdentifierContext | null;
    DOT(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionLiteralContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    literal(): LiteralContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionWinFunctionContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    identifier(): IdentifierContext;
    OVER(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode[];
    LPAREN(i: number): antlr.TerminalNode | null;
    windowExpression(): WindowExpressionContext;
    RPAREN(): antlr.TerminalNode[];
    RPAREN(i: number): antlr.TerminalNode | null;
    columnExpressionList(): ColumnExpressionListContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionTernaryOpContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    columnExpression(): ColumnExpressionContext[];
    columnExpression(i: number): ColumnExpressionContext | null;
    QUESTIONMARK(): antlr.TerminalNode;
    COLON(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionArrayContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    LBRACKET(): antlr.TerminalNode;
    RBRACKET(): antlr.TerminalNode;
    columnExpressionList(): ColumnExpressionListContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionTupleAccessContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    columnExpression(): ColumnExpressionContext;
    DOT(): antlr.TerminalNode;
    DECIMAL_LITERAL(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionParensContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    LPAREN(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    RPAREN(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionWinFunctionTargetContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext | null;
    OVER(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode | null;
    RPAREN(): antlr.TerminalNode | null;
    columnExpressionList(): ColumnExpressionListContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionAliasContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    columnExpression(): ColumnExpressionContext;
    alias(): AliasContext | null;
    AS(): antlr.TerminalNode | null;
    identifier(): IdentifierContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionPrecedence3Context extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    columnExpression(): ColumnExpressionContext[];
    columnExpression(i: number): ColumnExpressionContext | null;
    EQ_DOUBLE(): antlr.TerminalNode | null;
    EQ_SINGLE(): antlr.TerminalNode | null;
    NOT_EQ(): antlr.TerminalNode | null;
    LE(): antlr.TerminalNode | null;
    GE(): antlr.TerminalNode | null;
    LT(): antlr.TerminalNode | null;
    GT(): antlr.TerminalNode | null;
    IN(): antlr.TerminalNode | null;
    LIKE(): antlr.TerminalNode | null;
    ILIKE(): antlr.TerminalNode | null;
    GLOBAL(): antlr.TerminalNode | null;
    NOT(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionTimestampContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    TIMESTAMP(): antlr.TerminalNode;
    STRING_LITERAL(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionPrecedence2Context extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    columnExpression(): ColumnExpressionContext[];
    columnExpression(i: number): ColumnExpressionContext | null;
    PLUS(): antlr.TerminalNode | null;
    DASH(): antlr.TerminalNode | null;
    CONCAT(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionPrecedence1Context extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    columnExpression(): ColumnExpressionContext[];
    columnExpression(i: number): ColumnExpressionContext | null;
    ASTERISK(): antlr.TerminalNode | null;
    SLASH(): antlr.TerminalNode | null;
    PERCENT(): antlr.TerminalNode | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionIntervalContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    INTERVAL(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    interval(): IntervalContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionSubqueryContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    LPAREN(): antlr.TerminalNode;
    selectUnionStatement(): SelectUnionStatementContext;
    RPAREN(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionNegateContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    DASH(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionExtractContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    EXTRACT(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode;
    interval(): IntervalContext;
    FROM(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    RPAREN(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionCastContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    CAST(): antlr.TerminalNode;
    LPAREN(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    AS(): antlr.TerminalNode;
    columnTypeExpression(): ColumnTypeExpressionContext;
    RPAREN(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnExpressionOrContext extends ColumnExpressionContext {
    constructor(ctx: ColumnExpressionContext);
    columnExpression(): ColumnExpressionContext[];
    columnExpression(i: number): ColumnExpressionContext | null;
    OR(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnArgumentListContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    columnArgumentExpression(): ColumnArgumentExpressionContext[];
    columnArgumentExpression(i: number): ColumnArgumentExpressionContext | null;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnArgumentExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    columnLambdaExpression(): ColumnLambdaExpressionContext | null;
    columnExpression(): ColumnExpressionContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnLambdaExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    ARROW(): antlr.TerminalNode;
    columnExpression(): ColumnExpressionContext;
    LPAREN(): antlr.TerminalNode | null;
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext | null;
    RPAREN(): antlr.TerminalNode | null;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class ColumnIdentifierContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext | null;
    tableIdentifier(): TableIdentifierContext | null;
    DOT(): antlr.TerminalNode[];
    DOT(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: TableExpressionContext): void;
}
export declare class TableExpressionFunctionContext extends TableExpressionContext {
    constructor(ctx: TableExpressionContext);
    tableFunctionExpression(): TableFunctionExpressionContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableExpressionIdentifierContext extends TableExpressionContext {
    constructor(ctx: TableExpressionContext);
    tableIdentifier(): TableIdentifierContext;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableExpressionAliasContext extends TableExpressionContext {
    constructor(ctx: TableExpressionContext);
    tableExpression(): TableExpressionContext;
    alias(): AliasContext | null;
    AS(): antlr.TerminalNode | null;
    identifier(): IdentifierContext | null;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableExpressionSubqueryContext extends TableExpressionContext {
    constructor(ctx: TableExpressionContext);
    LPAREN(): antlr.TerminalNode;
    selectUnionStatement(): SelectUnionStatementContext;
    RPAREN(): antlr.TerminalNode;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableFunctionExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    identifier(): IdentifierContext;
    LPAREN(): antlr.TerminalNode;
    RPAREN(): antlr.TerminalNode;
    tableArgList(): TableArgListContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableIdentifierContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    identifier(): IdentifierContext;
    databaseIdentifier(): DatabaseIdentifierContext | null;
    DOT(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableArgListContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    tableArgExpression(): TableArgExpressionContext[];
    tableArgExpression(i: number): TableArgExpressionContext | null;
    COMMA(): antlr.TerminalNode[];
    COMMA(i: number): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class TableArgExpressionContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    columnIdentifier(): ColumnIdentifierContext | null;
    tableFunctionExpression(): TableFunctionExpressionContext | null;
    literal(): LiteralContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class DatabaseIdentifierContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    identifier(): IdentifierContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class FloatingLiteralContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    FLOATING_LITERAL(): antlr.TerminalNode | null;
    DOT(): antlr.TerminalNode | null;
    DECIMAL_LITERAL(): antlr.TerminalNode[];
    DECIMAL_LITERAL(i: number): antlr.TerminalNode | null;
    OCTAL_LITERAL(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class NumberLiteralContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    floatingLiteral(): FloatingLiteralContext | null;
    OCTAL_LITERAL(): antlr.TerminalNode | null;
    DECIMAL_LITERAL(): antlr.TerminalNode | null;
    HEXADECIMAL_LITERAL(): antlr.TerminalNode | null;
    INF(): antlr.TerminalNode | null;
    NAN_SQL(): antlr.TerminalNode | null;
    PLUS(): antlr.TerminalNode | null;
    DASH(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class LiteralContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    numberLiteral(): NumberLiteralContext | null;
    STRING_LITERAL(): antlr.TerminalNode | null;
    NULL_SQL(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class IntervalContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    SECOND(): antlr.TerminalNode | null;
    MINUTE(): antlr.TerminalNode | null;
    HOUR(): antlr.TerminalNode | null;
    DAY(): antlr.TerminalNode | null;
    WEEK(): antlr.TerminalNode | null;
    MONTH(): antlr.TerminalNode | null;
    QUARTER(): antlr.TerminalNode | null;
    YEAR(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class KeywordContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    AFTER(): antlr.TerminalNode | null;
    ALIAS(): antlr.TerminalNode | null;
    ALL(): antlr.TerminalNode | null;
    ALTER(): antlr.TerminalNode | null;
    AND(): antlr.TerminalNode | null;
    ANTI(): antlr.TerminalNode | null;
    ANY(): antlr.TerminalNode | null;
    ARRAY(): antlr.TerminalNode | null;
    AS(): antlr.TerminalNode | null;
    ASCENDING(): antlr.TerminalNode | null;
    ASOF(): antlr.TerminalNode | null;
    AST(): antlr.TerminalNode | null;
    ASYNC(): antlr.TerminalNode | null;
    ATTACH(): antlr.TerminalNode | null;
    BETWEEN(): antlr.TerminalNode | null;
    BOTH(): antlr.TerminalNode | null;
    BY(): antlr.TerminalNode | null;
    CASE(): antlr.TerminalNode | null;
    CAST(): antlr.TerminalNode | null;
    CHECK(): antlr.TerminalNode | null;
    CLEAR(): antlr.TerminalNode | null;
    CLUSTER(): antlr.TerminalNode | null;
    CODEC(): antlr.TerminalNode | null;
    COLLATE(): antlr.TerminalNode | null;
    COLUMN(): antlr.TerminalNode | null;
    COMMENT(): antlr.TerminalNode | null;
    CONSTRAINT(): antlr.TerminalNode | null;
    CREATE(): antlr.TerminalNode | null;
    CROSS(): antlr.TerminalNode | null;
    CUBE(): antlr.TerminalNode | null;
    CURRENT(): antlr.TerminalNode | null;
    DATABASE(): antlr.TerminalNode | null;
    DATABASES(): antlr.TerminalNode | null;
    DATE(): antlr.TerminalNode | null;
    DEDUPLICATE(): antlr.TerminalNode | null;
    DEFAULT(): antlr.TerminalNode | null;
    DELAY(): antlr.TerminalNode | null;
    DELETE(): antlr.TerminalNode | null;
    DESCRIBE(): antlr.TerminalNode | null;
    DESC(): antlr.TerminalNode | null;
    DESCENDING(): antlr.TerminalNode | null;
    DETACH(): antlr.TerminalNode | null;
    DICTIONARIES(): antlr.TerminalNode | null;
    DICTIONARY(): antlr.TerminalNode | null;
    DISK(): antlr.TerminalNode | null;
    DISTINCT(): antlr.TerminalNode | null;
    DISTRIBUTED(): antlr.TerminalNode | null;
    DROP(): antlr.TerminalNode | null;
    ELSE(): antlr.TerminalNode | null;
    END(): antlr.TerminalNode | null;
    ENGINE(): antlr.TerminalNode | null;
    EVENTS(): antlr.TerminalNode | null;
    EXISTS(): antlr.TerminalNode | null;
    EXPLAIN(): antlr.TerminalNode | null;
    EXPRESSION(): antlr.TerminalNode | null;
    EXTRACT(): antlr.TerminalNode | null;
    FETCHES(): antlr.TerminalNode | null;
    FINAL(): antlr.TerminalNode | null;
    FIRST(): antlr.TerminalNode | null;
    FLUSH(): antlr.TerminalNode | null;
    FOR(): antlr.TerminalNode | null;
    FOLLOWING(): antlr.TerminalNode | null;
    FORMAT(): antlr.TerminalNode | null;
    FREEZE(): antlr.TerminalNode | null;
    FROM(): antlr.TerminalNode | null;
    FULL(): antlr.TerminalNode | null;
    FUNCTION(): antlr.TerminalNode | null;
    GLOBAL(): antlr.TerminalNode | null;
    GRANULARITY(): antlr.TerminalNode | null;
    GROUP(): antlr.TerminalNode | null;
    HAVING(): antlr.TerminalNode | null;
    HIERARCHICAL(): antlr.TerminalNode | null;
    ID(): antlr.TerminalNode | null;
    IF(): antlr.TerminalNode | null;
    ILIKE(): antlr.TerminalNode | null;
    IN(): antlr.TerminalNode | null;
    INDEX(): antlr.TerminalNode | null;
    INJECTIVE(): antlr.TerminalNode | null;
    INNER(): antlr.TerminalNode | null;
    INSERT(): antlr.TerminalNode | null;
    INTERVAL(): antlr.TerminalNode | null;
    INTO(): antlr.TerminalNode | null;
    IS(): antlr.TerminalNode | null;
    IS_OBJECT_ID(): antlr.TerminalNode | null;
    JOIN(): antlr.TerminalNode | null;
    JSON_FALSE(): antlr.TerminalNode | null;
    JSON_TRUE(): antlr.TerminalNode | null;
    KEY(): antlr.TerminalNode | null;
    KILL(): antlr.TerminalNode | null;
    LAST(): antlr.TerminalNode | null;
    LAYOUT(): antlr.TerminalNode | null;
    LEADING(): antlr.TerminalNode | null;
    LEFT(): antlr.TerminalNode | null;
    LIFETIME(): antlr.TerminalNode | null;
    LIKE(): antlr.TerminalNode | null;
    LIMIT(): antlr.TerminalNode | null;
    LIVE(): antlr.TerminalNode | null;
    LOCAL(): antlr.TerminalNode | null;
    LOGS(): antlr.TerminalNode | null;
    MATERIALIZE(): antlr.TerminalNode | null;
    MATERIALIZED(): antlr.TerminalNode | null;
    MAX(): antlr.TerminalNode | null;
    MERGES(): antlr.TerminalNode | null;
    MIN(): antlr.TerminalNode | null;
    MODIFY(): antlr.TerminalNode | null;
    MOVE(): antlr.TerminalNode | null;
    MUTATION(): antlr.TerminalNode | null;
    NO(): antlr.TerminalNode | null;
    NOT(): antlr.TerminalNode | null;
    NULLS(): antlr.TerminalNode | null;
    OFFSET(): antlr.TerminalNode | null;
    ON(): antlr.TerminalNode | null;
    OPTIMIZE(): antlr.TerminalNode | null;
    OR(): antlr.TerminalNode | null;
    ORDER(): antlr.TerminalNode | null;
    OUTER(): antlr.TerminalNode | null;
    OUTFILE(): antlr.TerminalNode | null;
    OVER(): antlr.TerminalNode | null;
    PARTITION(): antlr.TerminalNode | null;
    POPULATE(): antlr.TerminalNode | null;
    PRECEDING(): antlr.TerminalNode | null;
    PREWHERE(): antlr.TerminalNode | null;
    PRIMARY(): antlr.TerminalNode | null;
    RANGE(): antlr.TerminalNode | null;
    RELOAD(): antlr.TerminalNode | null;
    REMOVE(): antlr.TerminalNode | null;
    RENAME(): antlr.TerminalNode | null;
    REPLACE(): antlr.TerminalNode | null;
    REPLICA(): antlr.TerminalNode | null;
    REPLICATED(): antlr.TerminalNode | null;
    RIGHT(): antlr.TerminalNode | null;
    ROLLUP(): antlr.TerminalNode | null;
    ROW(): antlr.TerminalNode | null;
    ROWS(): antlr.TerminalNode | null;
    SAMPLE(): antlr.TerminalNode | null;
    SELECT(): antlr.TerminalNode | null;
    SEMI(): antlr.TerminalNode | null;
    SENDS(): antlr.TerminalNode | null;
    SET(): antlr.TerminalNode | null;
    SETTINGS(): antlr.TerminalNode | null;
    SHOW(): antlr.TerminalNode | null;
    SOURCE(): antlr.TerminalNode | null;
    START(): antlr.TerminalNode | null;
    STOP(): antlr.TerminalNode | null;
    SUBSTRING(): antlr.TerminalNode | null;
    SYNC(): antlr.TerminalNode | null;
    SYNTAX(): antlr.TerminalNode | null;
    SYSTEM(): antlr.TerminalNode | null;
    TABLE(): antlr.TerminalNode | null;
    TABLES(): antlr.TerminalNode | null;
    TEMPORARY(): antlr.TerminalNode | null;
    TEST(): antlr.TerminalNode | null;
    THEN(): antlr.TerminalNode | null;
    TIES(): antlr.TerminalNode | null;
    TIMEOUT(): antlr.TerminalNode | null;
    TIMESTAMP(): antlr.TerminalNode | null;
    TOTALS(): antlr.TerminalNode | null;
    TRAILING(): antlr.TerminalNode | null;
    TRIM(): antlr.TerminalNode | null;
    TRUNCATE(): antlr.TerminalNode | null;
    TO(): antlr.TerminalNode | null;
    TOP(): antlr.TerminalNode | null;
    TTL(): antlr.TerminalNode | null;
    TYPE(): antlr.TerminalNode | null;
    UNBOUNDED(): antlr.TerminalNode | null;
    UNION(): antlr.TerminalNode | null;
    UPDATE(): antlr.TerminalNode | null;
    USE(): antlr.TerminalNode | null;
    USING(): antlr.TerminalNode | null;
    UUID(): antlr.TerminalNode | null;
    VALUES(): antlr.TerminalNode | null;
    VIEW(): antlr.TerminalNode | null;
    VOLUME(): antlr.TerminalNode | null;
    WATCH(): antlr.TerminalNode | null;
    WHEN(): antlr.TerminalNode | null;
    WHERE(): antlr.TerminalNode | null;
    WINDOW(): antlr.TerminalNode | null;
    WITH(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class KeywordForAliasContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    DATE(): antlr.TerminalNode | null;
    FIRST(): antlr.TerminalNode | null;
    ID(): antlr.TerminalNode | null;
    KEY(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class AliasContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    IDENTIFIER(): antlr.TerminalNode | null;
    keywordForAlias(): KeywordForAliasContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class IdentifierContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    IDENTIFIER(): antlr.TerminalNode | null;
    interval(): IntervalContext | null;
    keyword(): KeywordContext | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class IdentifierOrNullContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    identifier(): IdentifierContext | null;
    NULL_SQL(): antlr.TerminalNode | null;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
export declare class EnumValueContext extends antlr.ParserRuleContext {
    constructor(parent: antlr.ParserRuleContext | null, invokingState: number);
    STRING_LITERAL(): antlr.TerminalNode;
    EQ_SINGLE(): antlr.TerminalNode;
    numberLiteral(): NumberLiteralContext;
    get ruleIndex(): number;
    accept<Result>(visitor: ClickHouseParserVisitor<Result>): Result | null;
}
